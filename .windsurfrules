## Project Overview

1. **Framework**: Next.js 15 with App Router.
2. **Language**: TypeScript (strict mode enabled).
3. **Core Libraries**:
   - UI Framework: Tailwind CSS with ShadcN components.
   - State Management: Zustand (client state) and TanStack Query (server state).
   - Animations: Framer Motion.
   - Validation: Zod.
   - Backend: Appwrite for authentication and database services.

### Code Standards

1. Default to **Server Components** unless `'use client'` is explicitly required.
2. Always use **TypeScript in strict mode**.
3. Follow ESLint and Prettier configurations specified in the workspace.
4. Always validate props using TypeScript interfaces or utility types (e.g., `Pick`, `Omit`).
5. Enforce modular and reusable components:
   - Include loading, error, and empty states for all components.
   - Document all exported components with examples and accessibility notes.
6. Modular, readable, and maintainable code should follow separation of concerns (e.g., logic, UI, and state management should be isolated in respective files).
7. Centralize error-handling logic with reusable utility functions or hooks, ensuring consistent API response handling.

### Folder and File Management

1. Follow the modular structure defined for WYOS:
   ```
   src/
   ├── app/ # Next.js App Router routes
   │ ├── (auth)/ # Authentication routes
   │ ├── (core)/ # Protected features
   │ └── (marketing)/ # Public pages
   ├── components/ # React components
   │ ├── auth/ # Auth components
   │ ├── core/ # Feature components
   │ ├── marketing/ # Marketing components
   │ ├── shared/ # Shared components
   │ └── ui/ # UI components
   ├── lib/ # Utility functions
   │ ├── actions/ # Server actions
   │ ├── config/ # App configurations
   │ ├── hooks/ # Custom React hooks
   │ ├── providers/ # React providers
   │ └── utils/ # Utility functions
   ├── models/ # Appwrite models
   │ ├── client/ # Client-side config
   │ └── server/ # Server-side config
   ├── store/ # State management
   ├── types/ # TypeScript types
   └── middleware.ts # Next.js middleware
   ```
2. Use **PascalCase** for components, **camelCase** for hooks, and **kebab-case** for file and directory names.
3. Keep feature-specific logic self-contained (e.g., `knowledge`, `resources`).
4. Do not modify files in `/node_modules/` or generated folders (e.g., `/dist/`, `/out/`).
5. Maintain modular, feature-based folder structures (`src/app/`, `src/components/`).
6. Avoid modifying files in critical folders (e.g., `/lib/actions/` or `/core/`) without explicit approval.

### State Management

1. Use **Zustand** for client-side state management with immer and persist middleware.
   - Use **immer** for immutable state updates.
   - Persist state (e.g., authentication, preferences) using `zustand/persist` middleware.
2. Use **TanStack Query** for server-side state management with caching and hydration.
   - Define query keys and stale times for consistency (e.g., `['knowledge']`, `['resources']`).
   - Define query keys with descriptive names based on features and parameters (e.g., ['knowledge', { category: 'productivity' }]).

### API Usage

1. Always follow the API response structure: `{ success, error, data }`.
2. Use Appwrite’s SDK for authentication and database queries.
3. Avoid hardcoding API endpoints; reference them from the `src/lib/config` directory.
4. Avoid using experimental or deprecated APIs unless explicitly instructed.

### Accessibility

1. Ensure all interactive elements include:
   - ARIA attributes.
   - Keyboard navigation support.
   - Proper focus-visible styles.
2. Follow WCAG 2.1 standards for color contrast and readability.
3. Test all new features for screen reader compatibility.

### Security and Validation

1. Use **Zod** for input validation across forms and API calls.
2. Sanitize user-generated content using `DOMPurify`.
3. Store sensitive credentials securely using environment variables.

Project Environment Variables:

```env
NEXT_PUBLIC_APPWRITE_PROJECT_ID=
NEXT_PUBLIC_APPWRITE_ENDPOINT=https://cloud.appwrite.io/v1
APPWRITE_API_KEY=

APPWRITE_DATABASE_ID=

NEXT_PUBLIC_APPWRITE_TEAMS_ADMIN=
NEXT_PUBLIC_APPWRITE_TEAMS_MEMBERS=

// Stripe Public
NEXT_PUBLIC_STRIPE_PRICE_MONTHLY=
NEXT_PUBLIC_STRIPE_PRICE_ANNUAL=

// Stripe Private (Server-side only)
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=

NEXT_PUBLIC_APP_URL=http://localhost:3000
```

### Performance Optimization

1. Always prioritize performance in code:
   - Use lazy loading for components and assets where applicable.
   - Optimize server-side rendering for large datasets or components.
2. Optimize server-side rendering for large datasets using streaming or pagination.
3. Minimize re-renders by memoizing expensive computations and callback functions.
4. Avoid inline functions in JSX to reduce unnecessary re-renders.

### Testing

1. Write unit tests for all components and hooks using **Vitest** and **React Testing Library**.
2. Include integration tests for workflows like:
   - User authentication.
   - Knowledge/resource filtering.
   - Form submissions.
3. Perform accessibility testing with `axe-core` to ensure compliance.
4. Ensure all new features are tested for accessibility, performance, and edge cases.
5. Use **DeepSource** for static analysis and code quality.

### Documentation

1. Provide JSDoc-style comments for all public functions and components.
2. Maintain a `README.md` file in each feature folder explaining:
   - The purpose of the feature.
   - How to test it.
   - Key dependencies.

## General Interaction Guidelines:

- Cascade AI must ask for clarification when uncertain about a task and avoid making assumptions.
- Avoid generating code that is not directly related to the task at hand.
- Ensure all AI-generated code is:
  - Well-documented with clear comments.
  - Modular, readable, and maintainable.
  - Free of bugs and errors.
